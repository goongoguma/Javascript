1. DOM (Document Object Model)
-> 브라우저는 웹문서(html,xml,svg)를 로드한 후, 파싱하여 DOM을 생성한다. 
-> 브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를  DOM이라 한다. 
-> 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다.
DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌더링에 반영된다. 
-> 웹 문서의 동적 변경을 위해 DOM은 프로그래밍 언어가 자신에 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를  갖는 자바스크립트 객체로 제공되며 이를 DOM API라고 부른다. 
-> 즉, 정적인 웹페이지에 접근하여 동적으로 웹페이지를 변경하기 위한 유일한 방법은 메모리 상에 존재하는 DOM을 변경하는 것이며 이를 위해 DOM에 접근하고 변경이 가능하게 하는 프로퍼티와 메소드의 집합인 DOM API가 필요하다.
-> DOM은 다음 두 가지 기능을 담당한다.
 - HTML 문저에 대한 모델 구성 : 브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성한다. 이때 모델은 객체의 트리로 구성되는데 이것을 DOM tree라 한다.
 - HTML 문서 내의 각 요소에 접근 / 수정 : DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공한다. DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다.

 2. DOM tree
 -> DOM tREE는 브라우저가 HTML 문서를 로드한 후 생성하는 모델을 의미. 객체의 트리로 구조화되어 있기 때문에 DOM tree라 부른다. 
 -> DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다. 요소의 중첩관계는 객체의 트리로 구조화하여 부자관계를 표현한다. DOM tree의 진입점은 document 객체이며 최종점은 요소의 텍스트를 나타내는 객체이다. 

 DOM tree는 네 종류의 노드로 구성된다.
 - 문서노드(Document Node)
 -> 트리의 최상위에 존재, 각각 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 한다. 즉 DOM tree에 접근하기 위한 시작점(entry point)이다.
 - 요소 노도(Element Node)
 -> 요소 노드는 HTML 요소를 표현한다. HTML 요소는 중첩에 의해 부자 관계를 가지며 이 부자 관계를 통해 정보를 구조화 한다. 따라서 요소 노드는 문서의 구조를 서술한다고 말 할 수 있다. 어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다. 모든 요소 노드는 요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성된다. 
 - 어트리뷰트 노드(Attribute Node)
 -> 어트리뷰트 노드는 HTML 요소의 어트리뷰트를 표현한다. 어트리뷰트 노드는 해당 어트리뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현된다. 따라서 해당 요소 노드를 찾아 접근하면 어트리뷰트를 참조 및 수정이 가능하다.
 - 텍스트 노드(Text Node)
 -> 텍스트 노드는 html 요소의 텍스트를 표현한다. 텍스트 노드는 요소 노드의 자식이며 자신의 자식 노드를 가질 수 없다. 즉 텍스트 노드는 DOM tree의 최종단이다. 

 ================================================================================================

 *동기식 처리모델 vs 비동기식 처리 모델*

- 동기식 처리 모델 (Synchronous processing model)
 -> 동기식 처리 모델(Synchronous processing model)은 직렬적으로 테스크를 수행한다. 즉 테스크는 순차적으로 실행되며 어떤 작업이 수행 중이면 다음 작업은 대기하게 된다.
 -> 예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때, 서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 태스크들은 블로킹 된다. 

 - 비동기식 처리 모델 (Asynchronous processing model)
 -> 비동기식 처리 모델은 병렬적으로 태스크를 수행한다. 즉 태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행한다.
 -> 예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 태스크를 수행할 때, 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 태스크를 수행한다. 이후 서버로부터 데이터가 응답되면 이벤트가 발생하고 이베트 핸들러가 데이터를 가지고 수행할 태스크를 계속해 수행한다. 
 -> 자바스크립트의 대부분의 DOM 이벤트와 Timer 함수, Ajax 요청은 비동기식 처리 모델로 동작한다. 

 =================================================================================================

 *EVENT*

1. Introduction
-> 브라우저에서의 이벤트란 예를 들어 사용자가 버튼을 클릭했을 때, 웹페이지가 로드되었을 때와 같은 것인데 이것은 DOM 요소와 관련이 있다.
-> 이벤트가 발생하면 누군가 이를 감지할 수 있어야 하며 그에 대응하는 처리를 호출해 주어야 한다. 
-> 브라우저는 이벤트를 감지할 수 있으며 이벤트 발생 시에는 통지해 준다. 이 과정을 통해 사용자와 웹페이지는 상호작용이 가능하게 된다. 
-> 이벤트는 그에 맞는 반응을 위해 일반적으로 함수에 연결되며 그 함수는 이벤트가 발생하기 전에는 실행되지 않다가 이벤트가 발생되면 실행한다. 이 함수를 이벤트 핸들러라 하며 이벤트에 대응하는 처리를 기술한다. 

2. 이벤트 루프와 동시성
-> 브라우저는 단일 쓰레드에서 이벤트 드리븐 방식으로 동작한다.
-> 단일 쓰레드는 쓰레드가 하누뿐이라는 의미이며 이말은 곧 하나의 작업만을 처리할 수 있다는 것을 의미한다. 하지만 실제로 동작하는 웹 애플리케이션은 많은 task가 동시에 처리되는 것처럼 느껴진다. 이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프다. 

- 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 나뉜다.
 - Call Stack (호출 스택)
 -> 작업이 요청되면(함수 호출) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다.
 - Heap
 -> 동적으로 생성된 객체 인스턴스가 할당되는 영역이다. 

이와 같이 자바스크립트 엔진은 작업이 요청되면 Call Stack을 사용하여 요청된 작업을 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성을 지원하기 위해 필요한 비동기 요청 처리는 자바스크립트 엔진을 구동하는 환경 즉 브라우저(또는 Node.js)가 담당한다. 
 - Event Queue(Task Queue)
 -> 비동기 처리 함수의 콜백함수, 비동기식 이벤트 핸들러, Timer 함수의 콜백 함수가 보관되는 영역으로 이벤트 루프에 의해 특정 시점에 순차적으로 Call Stack으로 이동되어 실행된다.
 - Event Loop
 -> Call Stack내에서 현재 실행중인 task가 있는지 그리고 Event Queue에 task가 있는지 반복하여 확인한다. 만약 Call Stack이 비어있다면 Event Queue 내의 task가 Call Stack으로 이동하고 실행된다. 

