1. 실행 컨텍스트</br>
-> 실행 컨텍스트는 scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다.</br>
   실행 컨텍스트를 바로 이해하지 못하면 코드 독해가 어려워지며 디버깅도 매우 곤란해 질 것이다.

- ECMAScript 스펙에 따르면 실행 컨텍스트를 샐행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의한다. 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경이라고 말할 수 있겠다. 실행 가능한 코드는 아래와 같다. </br>
  - 전역 코드 : 전역 영역에 존재하는 코드
  - 함수 코드 : 함수 내에 존재하는 코드
  - Eval 코드 : eval 함수로 실행되는 코드 (사용X)

일반적으로 실행 가능한 코드는 전역 코드와 함수 내 코드이다.</br>

자스엔진은 코드를 실행하기 위하여 실행에 필요한 여러가지 정보를 알고 있어야 한다.</br>
- 변수 : 전역변수, 지역변수, 매개변수, 객체의 프로퍼티</br>
- 함수 선언</br>
- 변수의 유효범위(Scope)</br>
- this</br>

이와 같이 실행에 필요한 정보를 형상화하고 구분하기 위해 자바스크립트 엔진은 실행 컨텍스트를 </br>객체의 형태로 관리한다.

var x = 'xxx';</br>

function foo () {</br>
  var y = 'yyy';</br>

  function bar () {</br>
    var z = 'zzz';</br>
    console.log(x + y + z);</br>
  }</br>
  bar();</br>
}</br>
foo();</br>

위 코드를 실행하면 아래와 같이 실행 컨텍스트 스택이 생성하고 소멸한다. 현재 실행 중인 컨텍스트에서 이 컨텍스트와 관련없는 코드 (예를 들어 다른 함수)가 실행되면 새로운 컨텍스트가 생성된다. 이 컨텍스트는 스택에 쌓이게 되고 컨트롤(제어권)이 이동한다. </br>

- 컨트롤이 실행 가능한 코드로 이동하면 논리적 스택 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 스택은 후입선출(Last In First Out)의 구조를 가지는 나열 구조이다.
- 전역 코드(Global code)로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다. 
- 함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며 직전에 실행된 코드 블록의 실행 컨텍스트 위에 쌓인다.
- 함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다. 

2. 실행 컨텍스트의 3가지 객체</br>
-> 실행 컨텍스트는 실행 가능한 코드를 형상화 하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 가지며 3가지 프로퍼티를 소유한다. (블로그 저자가 임의의 이름으로 만든 3가지의 프로퍼티이다.)</br>

2-1. Variable Object (VO / 변수객체)</br>
-> 실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보들을 담을 객체를 생성한다. 이를 variable object(변수 객체)라고 한다. 변수 객체는 코드가 실행될 때 엔진에 의해 참조되며 코드에서는 접근할 수 없다.</br>

변수객체는 아래의 정보를 담는 객체이다.</br>
-> 변수</br>
-> 매개변수와 인수정보 </br>
-> 함수 선언(함수 표현식은 제외)</br>

변수 객체는 실행 컨텍스트의 프로퍼티이기 때문에 값을 갖는데 이 값은 다른 객체를 가리킨다. 그런데 전역 코드 실행시 생성되는 전역 컨텍스트의 경우와 함수를 실행할 때 생성되는 함수 컨텍스트의 경우, 가리키는 객체가 다르다. 이는 전역 코드와 함수의 내용이 다르기 때문이다. 예를 들어 전역 코드에는 매개변수가 없지만 함수에는 매개변수가 있다. </br>

변수 객체가 가리키는 객체는 아래와 같다.</br>

- 전역 컨텍스트의 경우</br>
-> 변수 객체는 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역객체를 가리킨다. 전역 객체는 전역에 선언된 전역 변수와 전역 함수를 프로퍼티로 소유한다. </br>

- 함수 컨텍스트의 경우</br>
-> 변수 객체는 Activation Object(활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가된다. </br>

2-2. Scope Chain (SC)</br>
-> 스코프 체인은 일종의 리스트로서 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있는 개념이다. 즉, 스코프 체인은 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고있는 전역 객체(GO) 또는 활성 객체(AO)의 리스트를 가리킨다.</br>
-> 엔진은 이를 통해 변수의 스코프를 파악한다. 함수가 중첩 상태일 때 하위함수 내에서 상위함수의 유효범위까지 참조할 수 있는데 이것은 스코프 체인을 검색하였기 때문이다. 함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인에 포함된다. 함수 실행중에 변수를 만나면 그 변수를 우선 현재 Scope, 즉 활성 객체에서 검색해보고 만약 검색에 실패하면 스코프 체인에 담겨진 순서대로 그 검색을 이어가게 되는 것이다. 이것이 스코프 체인이라고 불리는 이유다.</br>
-> 예를 들어 함수 내의 코드에서 변수를 참조하면 엔진은 스코프 체인의 첫번째 리스트가 가리키는 활성객체에 점근하여 변수를 검색한다.
만일 검색에 실패하면 다음 리스트가 가리키는 전역 객체 또는 활성 객체를 검색한다. 이와 같이 순차적으로 스코프 체인에서 변수를 검색하는데 결국 검색에 실패하면 정의되지 않은 변수에 접근하는 것으로 판단하여 reference 에러를 발생시킨다. 스코프 체인은 [[scope]] 프로퍼티로 참조할 수 있다. </br>

2-3. this value</br>
-> this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.</br>

3. 실행 컨텍스트의 생성 과정</br>

var x = 'xxx';</br>

function foo () {</br>
  var y = 'yyy';</br>

  function bar () {</br>
    var z = 'zzz';</br>
    console.log(x + y + z);</br>
  }</br>
  bar();</br>
}</br>

foo();</br>

3-1. 전역 코드에의 진입</br>
-> 컨트롤이 실행 컨텍스트에 진입하기 이전에 유일한 전역 객체(Global Object)가 생성된다. 전역 객체는 단일 사본으로 존재하며 이 객체의 프로퍼티는 코드의 어떠한 곳에서도 접근할 수 있다. 초기 상태의 전역 객체에는 빌트인 객체(Math,String,Array 등)와 BOM, DOM이 설정되어 있다. </br>
-> 전역 객체가 생성된 이후, 전역 코드로 컨트롤이 진입하면 전역 실행 컨텍스트가 생서오디고 실행 컨텍스트 스택에 쌓인다. </br>

그 후 이 실행 컨텍스트를 바탕으로 이하의 처리가 실행된다.</br>

* 스코프 체인의 생성과 초기화</br>

* Variable Instantiation(변수 객체화) 실행</br>
-> 변수 객체화는 아래의 순서로 변수 객체에 프로퍼티와 값을 set한다.</br>
  - 매개변수가 변수객체의 프로퍼티로, 인수가 값으로 설정된다.</br>
  - 대상 코드 내의 함수 선언을 대상으로 변수 객체의 프로퍼티로, 생성된 함수 객체가 값으로 설정된다.(함수 호이스팅)</br>
  - 대상 코드 내의 변수 선언을 대상으로 변수명이 변수 객체의 프로퍼티로 undefiend가 값으로 설정된다. (변수 호이스팅)</br>

* this value 결정</br>

* 스코프 체인의 생성과 초기화</br>
실행 컨텍스트가 생성된 이후 가장 먼저 스코프 체인의 생성과 초기화가 실행된다. 이때 스코프 체인은 천역 객체의 레퍼런스를 포함하는 리스트가 된다. </br>
* 변수 객체화 실행</br>
스코프 체인의 생성과 초기화가 종료하면 변수 객체화가 실행된다.</br>
변수 객체화는 변수 객체에 프로퍼티와 값을 추가하는 것을 의미한다.</br>
전역 코드의 경우, 변수 객체는 전역 객체를 가리킨다. </br>

- 함수 foo의 선언 처리</br>
-> 함수 선언은 변수 객체화 실행 순서와 같이 선언된 함수명 foo가 변수 객체의 프로퍼티로, 생성된 함수 객체가 값으로 설정된다. </br>
-> 생성된 함수 객체는 [[Scopes]] 프로퍼티를 가지게 된다. [[Scopes]] 프로퍼티는 함수 객체만이 소유하는 내부 프로퍼티로서 함수 객체가 실행되는 환경을 가리킨다. 따라서 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정한다. 내부 함수의  [[Scopes]] 프로퍼티는 자신의 실행 환경(Lexical Environment)과 자신을 포함하는 외부 함수의 실행 환경과 전역 객체를 가리키는데 이때 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 [[Scopes]] 프로퍼티가 가리키는 외부함수의 실행 환경은 소멸하지 않고 참조할 수 있다. 이것이 클로저이다. </br>

- 변수 x의 선언 처리</br>
-> 선언단계 : 변수 객체에 변수를 등록한다. 이 변수 객체는 스코프가 참조할 수 있는 대상이 된다.</br>
-> 초기화 단계 : 변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefiend로 초기화된다.</br>
-> 할당 단계 : undefiend로 초기화된 변수에 실제값을 할당한다. </br>

- 전역 코드의 실행</br>

var x = 'xxx';</br>

function foo () {</br>
  var y = 'yyy';</br>

  function bar () {</br>
    var z = 'zzz';</br>
    console.log(x + y + z);</br>
  }</br>
  bar();</br>
}</br>

foo();</br>

예제에서 전역 변수 x에 문자열 'xxx'할당과 함수 foo의 호출이 실행된다.</br>

전역 변수 x에 문자열 'xxx'를 할당할 때, 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 변수 객체를 선두부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값(xxx)을 할당한다. </br>

전역 코드의 함수 foo가 실행되기 시작하면 새로운 함수 실행 컨텍스트가 생성된다. 함수 foo의 실행 컨텍스트로 컨트롤이 이동하면 전역 코드의 경우와 마찬가지로 스코프 체인의 생성과 초기화 Variable Instantiation 실행, this value 결정이 순차적으로 실행된다.</br>

함수 코드의 스코프 체인의 생성과 초기화는 우선 Activation Object에 대한 레퍼런스를 스코프 체인의 선두에 설정하는 것으로 시작된다.</br>
Activation Object는 우선 arguments 프로퍼티의 초기화를 실행하고 그 후, Variable Instantiation가 실행된다. Activation Object는 스펙 상의 개념으로 프로그램이 Activation Object에 직접 접근할 수 없다. (Activation Object의 프로퍼티로의 접근은 가능하다)</br>

====================================================================================================================

1. 클로저 (closue)</br>
-> 클로저는 자스의 고유 개념이 아니라 함수를 일급 객체로 취급하는 함수형 언에서 사용되는 중요한 특성이다.</br>
-> 클로저는 내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미한다.</br>

function outerFunc() {</br>
  var x = 10;</br>
  var innerFunc = function () { console.log(x); };</br>
  innerFunc();</br>
}</br>

outerFunc(); // 10</br>

함수  outFunc 내에 내부함수 innerFunc가 선언되고 호출되었다. 이때 내부함수 innerFunc은 자신을 포함하고 있는 외부함수 outerFunc의 변수 x에 접근 할 수 있다. </br>
이것은 중첩된 함수의 스코프 레퍼런스를 차례대로 저장하고 있는 실행 컨텍스트의 스코프 체인을 자스 엔진이 검색하였기에 가능한 것이다. 
조금 더 자세히 설명하면 아래와 같다.</br>
- innerFunc 함수 내에서 변수 x를 검색한다. 검색한 결과가 없다.</br>
- 그 뒤 innerFunc 함수를 포함하는 외부 함수 outerFunc에서 변수 x를 검색한다. 검색이 성공하였다.</br>

이번에는 내부함수 innerFunc를 outerFunc내에서 호출하는 것이 아니라 반환하도록 변경해 보자.</br>

function outerFunc() {</br>
  var x = 10;</br>
  var innerFunc = function () { console.log(x); };</br>
  return innerFunc;</br>
}

// 함수 outerFunc를 호출하면 내부 함수 innerFunc가 반환된다. 그리고 함수 outerFunc의 실행 컨텍스트는 소멸한다</br>
var inner = outerFunc();</br>
inner(); // 10</br>

함수 outerFunc는 내부함수 innerFunc를 반환하고 생을 마감했다. 즉 함수 outerFunc는 실행된 이후 콜스택(실행 컨텍스트 스택)에서 제거되었으므로 함수 outerFunc의 변수 x또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법은 달리 없어 보인다.</br>
그러나 위 코드의 실행 결과는 변수 x의 값인 10이다. </br>
위 예제는 자신을 포함하고 있는 외부함수보다 내부함사구 더 오래 유지되는 경우인데 이때 내부함수가 외부함수의 지역 변수에 접근할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며 내부함수에 의해서 소멸하게 되는 특성을 클로저라고 부른다.</br>

클로저에 의해 참조되는 외부함수의 변수 즉 outerFunc 함수의 변수 x를 자유변수(free variable)라고 부른다. 클로저라는 이름은 자유변수에 함수가 닫혀있다라는 의미로 의역하면 자유변수에 엮여있는 함수라는 뜻이다. </br>

실행 컨텍스트의 관점에서 설명하면, 내부함수가 유효한 상태에서 외부함수가 종료하여 외부함수의 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 activation object(변수,함수 선언등의 정보를 가지고 있다)는 유효하여 내부함수가 스코프 체인을 통해 참조할 수 있는 것을 의미한다. </br>

즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다. </br>

2. 클로저의 활용</br>
-> 클로저는 자바스크립트의 강력한 기능이지만 성능적인 면과 자원적인 면에서 손해를 볼 수 있다. 무분별한 클로저의 사용은 득보다 실이 많다. 클로저를 사용하여할 장면에서 사용해야 하는데 사실 이것은 경험이 필요하다.</br>






