* 변수 -> 데이터의 위치(주소->위치식별자)를 기억하는 저장소

* type의 자료형은 값이 할당이 될 때 결정 되어진다

* pass-by-value -> 메모리에 들어있는 값을 복사해서 준다.

* var a={} / var b={} / a===b -> false (주소값이 다름)

* var 01={} / var 02=01 / a===b -> true (주소값이 넘어감)

* 연산자 계산의 기본은 우측부터

* var a=b={} / a===b -> a와 b는 같은 주소를 가지고있다

* 코드블럭 -> 구문들을 모아놓은 뒤 한번에 실행하기 위해 코드블럭을 사용한다

* 복습이나 예습할때 항상 코드를 손으로 꼭 쓰기

* 코딩은 연습에 연습에 연습이 필요 

* 프로퍼티의 이름 -> 빈문자열 포함해서 모든 문자

* 프로퍼티의 값 -> undefined를 포함한 모든것

* 프로퍼티는 ;이 아닌 ,로 끝낸다

* 생성자함수 생성방식 : new와 함께 객체를 생성하지 않아도 객체를 새로 생성가능하다. 

* 생성자 함수와 new의 관계 공부

* 인스턴스?

* 자바스크립트는 함수레벨 스코프, 타언어들은 블록레벨 스코프

* 함수의 바디 안이 아니면 다 전역변수이다.

* 자신의 지역에 있는 변수에 값이 없으면 자기 지역의 레벨 위로 이동해서 변수를 찾는다 만약 전역까지 다 뒤졌는데 값이 안나오는경우는 reference error가 뜬다

*this 공식
1. this는 전역객체를 가리킨다 (윈도우를 가리킨다.)
2. 예외가 2개 1. 생성자 함수 내에서의 this는 생성자 함수가 생성한 객체를 가리킨다.
	     2. 매서드 내에서 생성한 this는 매서드를 호출한 객체를 가리킨다. (메소드를 소유한 또는 호출한 객체(.앞에)를 가리킨다)

* this는 함수내에서 생성하지않아도 자동 생성되는것처럼 보인다(즉 함수안에 존재한다)

* 바인딩한다 -> 어떠한객체가 다른 객체를 가리키는것

* 생성자 함수를 호출할때 new를 붙인다. 

* 호스트 객체

* 전역변수는 윈도우의 프로퍼티이다. 

* 내부함수는 메서드가 아니다 그냥 함수다 즉 내부함수내에 사용된 this는 윈도우(전역함수)를 가리킨다 (콜백함수안의 this도 윈도우(전역함수)를 가리킨다 이것을 회피하기 위해 that을 쓴다)

* 자신이 소속된 객체의 프로퍼티를 가리키기 위해서 this를 사용한다. 

* 생성자함수와 new

*생성자함수의 작동방식 -> new는 생성자함수 첫 라인에 빈객체를 만든다 / this가 그 빈객체를 바인딩 하도록 만든다. / 메소드를 추가 / this를 리턴한다

* 객체 리터럴 방식과 생성자 함수 방식의 차이
객체리터럴은 object 생성자 함수가 만든다 -> object.prototype이 생성된다. 

*매서드로서 생성자함수로서 this의 사용법은 조금씩 다르다. 

==========================================================================================================================

Scope은 자바스크립트를 포함한 모든 프로그래밍 언어의 개본적인 개념으로 확실한 이해가 필요하다

Scope이란 변수에의 접근성과 생존기간(life-cycle)을 의미한다. 달리 말하자면 변수가 가지고 있는 참조 범위를 의미한다. 

* 자바스크립트의 Scope 종류는 다음과 같다. 

- 전역 Scope (Global) 
-> 코드 어디에서든지 참조할 수 있다. 

- 지역 Scope (Local or Function-level)
-> 정의된 함수내에서만 참조할 수 있다.

모든 변수는 Scope을 갖는다.

- 전역 변수 (Global variable)
-> 전역 Scope를 갖는 변수

- 지역 변수 (Local variable)
-> 지역 Scope를 갖는 변수

* 변수는 선언 위치(전역 또는 지역)에 의해 Scope를 가지게 된다. 즉 전역에서 선언된 변수는 전역 scope를 갖는 전역 변수이고 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 scope를 갖는 지역 변수가 된다. 

* 전역 scope를 갖는 전역 변수는 전역(코드 어디서든지)에서 참조할 수 있다. 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다. 

자바스크립트의 scope는 타 언어와는 다른 특징을 가지고 있다. 
- function-level scope 
-> function-level scope란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것이다. (단, ECMAScript 6에서 도입된 let keyword를 사용하면 block-level scope를 사용할 수 있다.)

* Global scope
-> 글로벌 영역에 변수를 선언하면 이 변수는 어느 곳에서든지 참조할 수 있는 global scope를 갖는 전역 변수가 된다. 전역 변수는 전역 객체(Globel Object) window의 프로퍼티이다. 
-> 자바스크립트는 타 언어와는 달리 특별한 시작점(Entry point)이 없어서 위 코드와 같이 글로벌 영역에 변수나 함수를 선언하기 쉽다.
-> 전역 변수의 사용은 변수명의 중복 등 여러 문제를 방생시키므로 가급적 사용을 억제하여야 한다.

* Non block-level scope
-> function 밖에서 선언된 변수는 코드 블록 내에서 선언되었다할지라도 모두 global scope를 갖게된다. 

* Function-level scope
-> 자바스크립트는 function-level scope를 사용한다. 즉 함수 내에서 선언된 매개변수와 변수는 함수의 외부에서는 유효하지 않다.
-> 내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있다. 클로저에서와 같이 내부함수가 더 오래 생존하는 경우, 타 언어와는 다른 움직임을 보인다. 
-> 함수(지역) 영역에서 전역변수를 참조할 수 있으므로 전역변수의 값도 변경할 수 있다. 내부 함수의 경우, 전역변수는 물론 상위 함수에서 선언한 변수에 접근/변경이 가능하다. 
-> 중첩 scope는 가장 인접한 지역을 우선하여 참조한다.

* 암묵적 전역(implied globals)
-> 내부에 변수가 존재하지 않을 경우 상위지역에서 변수의 이름을 찾고 존재하지 않으면 변수 x를 암묵적 전역변수로 선언한다. 

* Lexical scoping (Static scoping)
-> 자바스크립트는 함수가 선언된 시점에서의 유효범위를 갖는다. 

* 변수명의 중복
-> 전역변수의 무분별한 사용은 무척 위험하다. 전역변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역변수를 사용하여야 한다. 변수의 범위인 스코프는 좁을수록 좋다. 

* 최소한의 전역변수 사용
-> 전역변수 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역변수 사용을 위해 전역변수 객체 하나를 만들어 사용하는 것이다. 

* 즉시실행함수를 이용한 전역변수 사용 억제
-> 전역변수 사용을 억제하기 위해, 즉시 실행 함수(IIFE)를 사용할 수 있다. 이 방법을 사용하면 전역변수를 만들지 않으므로 라이브러리 등에 자주 사용된다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다. 

=================================================================================================================

자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에 argument 객체와 this를 암묵적으로 전달 받는다. 
자바스크립트의 경우 해당 함수 호출 패턴에 따라 this에 바인딩되는 객체가 달라진다. 

자바스크립으의 경우 함수 호출 패턴에 따라 어떤 객체를 this에 바인딩할 지가 결정된다. 즉, 호출 패턴에 따라 this의 참조값이 달라진다.

함수 호출패턴은 아래와 같다

- 함수 호출 패턴(Function Invocation Pattern)
- 메소드 호출 패턴(Method Invocation Pattern)
- 생성자 호출 패턴(Constructor Invocation Pattern)
- apply 호출 패턴(Apply Invocation Pattern)

* 함수 호출 패턴(Function Invocation Pattern)
-> 전역객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다. 
-> 전역객체는 전역 스코프(Global Scope)를 갖는 전역변수(Global variable)를 프로퍼티로 소유한다. 글로벌 영역에 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역 변수의 메소드이다. 
-> 기본적으로 this는 전역객체(Global object)에 바인딩된다. 전역함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩된다. 
-> 또한 메소드의 내부함수일 경우에도 this는 전역객체에 바인딩된다. 
-> 콜백함수의 경우에도 this는 전역객체에 바인딩된다. 
-> 메소드 호출 패턴이든 함수 호출 패턴이든 내부함수의 this는 모두 전역객체에 바인딩된다. 이러한 문제를 해소하기 위해 자바스크립트는 this 바인딩을 명시적으로 할 수 있는 call,apply 메소드를 제공한다. 

* 메소드 호출 패턴(Method Invocation Pattern)
-> 함수가 객체의 프로퍼티이면 메소드 호출 패턴으로 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체 즉 해당 메소드를 호출한 객체에 바인딩된다. 

* 생성자 호출 패턴(Constructor Invocation Pattern)
-> 자바스크립트의 생성자 함수는 말 그대로 객체를 생성하는 역할을 한다. 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.
-> 이는 반대로 생각하면 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다. 따라서 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼란을 방지하려는 노력을 한다. 
-> new 연산자와 함께 생성자 함수를 호출하면 this 바인딩이 메소드나 함수 호출 때와는 다르게 동작한다. 

- 생성자 함수 동작 방식
-> new 연산자와 함께 생성자 함수를 호출하면 다음과 같은 수순으로 동작한다.
1. 빈 객체 생성 및 this 바인딩
-> 생성자 함수의 코드가 실행되기 전 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 새로 생성하는 객체이다. 이후 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다. 그리고 생성된 빈 객체는 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. 
2. this를 통한 프로퍼티 생성
-> 생성된 빈 객체에 this를 사용하여 동적으로 프로퍼티나 메소드를 생성할 수 있다. this는 새로 생성된 객체를 가리키므로 this를 통해 생성한 프로퍼티와 메소드는 새로 생성된 객체에 추가된다. 
3. 생성된 객체 반환
-> 반환문이 없는 경우, this에 바인딩된 새로 생성한 객체가 반환된다. 명시적으로 this를 반환하여도 결과는 같다. 
-> 반환문이 this가 아닌 다른 객체를 명시적으로 반환하는 경우, this가 아닌 해당 객체가 반환된다. 이때 this를 반환하지 않은 함수는 생성자 함수로서의 역할을 수행하지 못한다. 따라서 생성자 함수는 반환문을 명시적으로 사용하지 않는다. 

- 객체 리터럴 방식과 생성자 함수 방식의 차이 
-> 객체 리터럴 방식과 생성자 함수 방식의 차이는 프로토타입 객체에 있다.
-> 객체 리터럴 방식의 경우, 생성된 객체의 프로토타입 객체는 Object.prototye이다.
-> 생성자 함수 방식의 경우, 생성된 객체의 프로토타입 객체는 Person.prototype이다. 

- 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우
-> 일반함수와 생성자 함수에 특별한 형식적 차이는 없으며 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. 
-> 그러나 객체 생성 목적으로 작성한 생성자 함수를 new 없이 호출하거나 일반합수에 new를 붙여 호출하면 오류가 발생할 수 있다. 일반함수와 생성자 함수의 호출시 this 바인딩 방식이 다르기 때문이다. 
-> 일반 함수를 호출하면 this는 전역객체에 바인딩되지만 new 연산자와 함께 생성한 함수를 호출하면 this는 생성자 함수가 암묵적으로 생성한 빈 객체에 바인딩된다. 
-> 생성자 함수를 new 없이 호출한 경우, 함수 Person 내부의 this는 전역객체를 가리키므로 name은 전역변수(window)에 바인딩된다. 또한 new와 함께 생성자 함수를 호출하는 경우에 암묵적으로 반환하던 this도 반환하지 않으며, 반환문이 없으므로 undefined를 반환하게 된다. 
-> 일반함수와 생성자 함수에 특별한 형식적 차이는 없기 때문에 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼란을 방지하려는 노력을 한다. 그러나 이러한 규칙을 사용한다 하더라도 실수는 발생할 수 있다.
-> 다시 말하지만 new 연산자와 함께 생성자 함수를 호출하는 경우, 생성자 함수 내부의 this는 생성자 함수에 의해 생성된 인스턴스를 가리킨다. 

* apply 호출 패턴(Apply Invocation Pattern)
-> this에 바인딩될 객체는 함수 호출 패턴에 의해 결정된다. 이는 자바스크립트 엔진이 수행하는 것이다. 이러한 자바스크립트 엔진의 암묵적 this 바인딩 이외에 this를 특정 객체에 명시적으로 바인딩하는 방법도 제공된다. 이것을 가능하게 하는것이 Function.prototype.apply, Function.prototype.call 메소드이다. 이 메소드들은 모든 함수 객체의 프로토타입 객체인 Function.prototype 객체의 메소드이다. 
-> Array.prototype.slice.apply(arguments)는 "Array.prototype.slice() 메소드를 호출하라. 단 this는 arguments 객체로 바인딩하라"는 의미가 된다.
결국 Array.prototype.slice() 메소드를 arguments 객체 자신의 메소드인 것처럼 arguments.slice()와 같은 형태로 호출하라는 것이다. 




