*2중 for문 연습해보기 

*문제를 풀기전에 문제를 명확하게 하는것이 중요 

*숙제문제 2번 -> 왜 개행이 되었는가 : console.log에 답이 달려있음 (console.log 자체에 개행의 의미를 가지고있음)

*문장에 빨간밑줄이 그어져있다고해서 에러가 난것이 아니라 고쳐야 하는 부분을 표시해 주는것이다. 

*console.log의 위치에 따라 개행이 결정된다. 

*개행을 할려면 string 내부에 enter를 치면 안된다. 
 
* for문 숙제 10번 계속 연습하기

*코드의 재사용은 반드시 필요하다 (중복의 제거->유지보수성를 계속 생각하도록)

*초기화문은 보통 while 앞에쓴다 

*while문은 많이 쓰지는 않지만 무한루프를 쓸 때 유용하다. (ex.게임)

*break : 조건을 만족하면 무한루프를 탈출할 수 있는 명령어

*continue : 자신 밑에 있는 로직을 실행하지 말고 건너뛰라는 명령어

*문자를 숫자와 연산하는 논리적이지 않은 행위를 하면 자바스크립트는 강제 형변환을 통해 해석하기 때문에 이런식의 경우는 피해야한다

*문자열을 숫자로 강제 형 변환을 시도할 때, 문자열 앞에 연산기호(+)를 붙이거나 *1을 붙이거나 parseInt, Number를 붙인다.(Number명령어는 객체를 생성하기 위해 존재하는 명령어이기 때문에 강제 형 변환을 할때 사용하는것은 좋지않다. 선생님이 추천하는 형변환은 +를 쓰는것. 하지만 독해를 하기 위해서는 모두 아는것이 좋다.)

*숫자를 문자열로 형 변환을 할때는 숫자와 문자열을 붙일때 +를 쓰는것을 추천

*빈 문자열은 false이지만 빈 객체는 true이다. 

*==(동등 연산자)와 ===(일치 연산자)의 차이점을 명확히 알고있어야한다.(입사시험때 나올 가능성이 크다)

*checking existence는 삼항연산자로 표현이 가능하다.

*자바스크립트는 멀티페러다임언어다. 일반적으로 객체지향형을 사용한다. 하지만 함수형도 알아두는것이 좋다.

*프로퍼티와 메소드를 가지고있는것이 객체이다.

*객체는 프로퍼티 이름과 값으로 이루어져있다.

*변수의 명령규칙 : 영문대소문자, _, $만 쓸 수 있다.

*메소드 : 객체의 프로퍼티 함수 

*객체를 만드는 방법은 세가지 :객체 리터럴, Object() 생성자 함수, 생성자 함수

*리터럴(literal): 값이 될 수있는 값 자체, 자스에서 함수는 값이 될 수 있음 하지만 타언어에서는 함수는 값이 될 수 없다. 

*객체 리터럴 : 객체 자체가 값이 될 수 있음 쉽게말해 객체를 값으로 부를때 객체 리터럴이라 한다. (안의 원리는 object 생성자함수이며 따라서 syntatic sugar라고 불린다)

*객체 리터럴 안에서의 프로퍼티는 0개 이상 있을 수 있다.

*인스턴스의 개념 알아두기 

*person.name -> person객체 내부에 있는 name의 값을 불러온다 

*동적프로퍼티 할당 : 자스에서는 빈객체를 만들고 프로퍼티를 나중에 추가할 수 있다.

*object () 생성자 함수는 사용자가 아니라 자스엔진이 쓰기위해 만들어 진 것. 문법만 알아놓으면 된다. 

*객체를 만드는 함수의 첫번째 글자는 대문자여야 한다.

*생성자 함수의 뜻은 객체를 생성하는 함수다

*문자열이지만 프로퍼티의 이름은 따옴표를 생략 할 수 있다. 단, 'first-name':'Ung-mo'같은 케밥케이스 프로퍼티는 제외다. first_name;과 같은 스네이크케이스와 firstName;과 같은 카멜케이스, FirstName과 같은 파스칼케이스는 써도 괜찮다.

*대괄호 표기법에는 내부에 항상 따옴표를 써줘야 한다.

*프로퍼티 삭제 delete 연산자는 되도록 안쓰는게 좋다.(자기자신이 쓰지않더라도 누군가가 쓸 수 있기 때문이다. delete로 객체를 지울수는 없다
대신 null을 할당하고 garbage collector가 지우도록 한다)

***Pass-by-reference
-> 객체의 바이트 사이즈는 알 수 없다. 객체의 바이트 사이즈는 코드가 작동되었을 때(run-time) 알 수 있다. 즉 메모리의 관리방식이 기본자료형과 다르다.
-> 객체는 기본자료형과 다른 부분인 메모리의 heap영역에 저장된다(기본자료형들은 stack영역에 저장된다) 
-> 주소를 공유한다 즉, 하나가 영향을 받으면 다른것도 영향을 받는다

* 내일 아침 mutable과 immutable의 차이점을 30분동안 설명해보기 

*함수를 정의하는 방식은 3가지가 있다.
 ->함수선언식, 함수표현식, function()생성자 함수(엔진이 쓰는 함수)

*함수표현식 -> 하나의 값으로 수렴되는 식 

*기명함수표현식과 익명함수표현식중 편한것을 쓰면된다.

*함수선언식은 표현식의 syntatic sugar이지만 조금씩 다르다(hoisting)
둘중하나 골라서 사용해도 가능함

***hoisting이란 모든 선언문(var,function,class 등등)이 스코프에 최상단에 옮겨진것처럼 작동한다는 뜻이다.(입사시험문제에 잘 나옴)
다시 말하면 코드에 가장 선두에서 선언전에 밑에 있는 모든 변수들을 참조하는것 단, 참조값은 undefined이다.
함수선언식은 함수 hoisting을 하는데 선두에서 함수를 호출 할 수 있다.  

*타언어에서는 코드블록이 유효범위 하지만 자스에서는 함수블록만이 유효범위 
즉 자스에서는 코드블록에 상관없이 변수가 재할당 될 수 있다. 

*함수 선언식 vs 함수 표현식

***일급 객체(first-class object)
-> 왜 함수가 값인지 알려준다

* 이번주 숙제 : 3일동안 배운내용들을 주욱 복습해서 모르는 내용들은 노트에 써서 가져오기
              포이마에 있는 예시 코드들도 한번씩 직접 쳐보면서 공부하는것을 추천 




 



