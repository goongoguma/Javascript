* 매개변수(Parameter,인자)</br>
-> 함수의 작업 실행을 위해 추가적인 정보가 필요할 때, 매겨변수를 지정</br>
-> 매개변수는 함수 내에서 변수와 동일하게 동작</br>

- 매개변수(인자) vs 인수</br>
-> 매개변수는 함수내에서 변수와 동일하게 메모리 공간을 확보, 함수에 전달한 인수는 매개변수에 할당.</br>
-> 인수를 전달하지 않으면 매개변수는 undefined로 초기화된다. </br>

- Call-by-value</br>
-> 기본자료형 인수는 값에 의한 호출(Call-by-value)로 동작</br>
-> 함수 호출 시 기본자료형 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 함수로 전달하는 방식</br>
-> 이때 함수 내에서 매개변수를 통해 값이 변경되어도 전달이 완료된 기본자료형 값은 변경X</br>

- Call-by-reference</br>
-> 객체형 인수는 참조에 의한 호출(Call-by-reference)로 동작한다. </br>
-> 이는 함수 호출 시 참조타입 인수를 함수에 매개변수로 전달할 때 객체의 참조값이 매개변수에 저장되어 함수로 전달되는 방식.</br>
-> 참조에 의한 호출로 인해 객체의 값이 변경되었을 때 전달되어진 참조형의 인수값도 같이 변경됨. </br>

* 반환값(return value)</br>
-> 함수는 자신을 호출한 코드에게 수행한 결과를 반환할 수 있다. </br>
- return 키워드는 함수를 호출한 코드(caller)에게 값을 반환할 때 사용한다.
- 함수는 배열등을 이용해 한번에 여러개의 값을 반환 가능
- 함수는 반환을 생략 가능. 이때 암묵적으로 undefined를 반환
- 자스 해석기는 return 키워드를 만나면 함수의 실행을 중단, 호출한 코드로 되돌아감 

* 함수 객체의 프로퍼티</br>
-> 함수는 객체, 따라서 프로퍼티를 가질 수 있음.</br>
-> 함수는 함수만의 표준 프로퍼티를 갖는다. </br>

* 함수의 프로퍼티</br>
- arguments 프로퍼티
-> arguments 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회가능한 유사 배열 객체이다. </br>
->함수 객체의 arguments 프로퍼티는 arguments 객체를 값으로 가지며 함수 내부에서 지역변수처럼 사용됨. 외부에서는 사용불가 </br>

매개변수는 인수로 초기화된다.</br>
-> 매개변수의 갯수보다 인수를 적게 전달했을 때 인수가 전달되지 않은 매개변수는 undefined로 초기화된다.</br>
-> 매개변수의 갯수보다 인수를 더 많이 전달한 경우, 초과된 인수는 무시된다. </br>

arguments 객체는 매개변수 갯수가 확정되지 않은 가변 인자 함수를 구현할 때 유용하게 사용된다. 

자스는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달됨.

arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 유사배열객체이다. 

유사배열객체 -> length 프로퍼티를 가진 객체.
단, 배열이 아니므로 배열 메소드를 사용하게되면 에러발생

- caller 프로퍼티</br>
-> caller 프로퍼티는 자신을 호출한 함수를 의미한다</br>

- length 프로퍼티</br>
-> length 프로퍼티는 함수 정의 시 작성된 매개변수 갯수를 의미 </br>

- name 프로퍼티</br>
-> 함수명을 나타냄, 기명함수의 경우 함수명을 값으로 갖고 익명함수의 경우 빈문자열을 값으로 갖는다.</br>

- __proto__프로퍼티(=[[Prototype]])</br>
-> ECMAScript spec에서 모든 객체는 자신의 프로토타입을 가기키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다. </br>
-> 함수의 프로토타입 객체는 Function.prototype이며 이것 역시 함수이다. </br>

- prototype 프로퍼티</br>
-> 함수 객체만이 가지고있는 프로퍼티이며 자스 객체지향의 근간</br>
-> prototype프로퍼티와  [[Prototype]] 프로퍼티는 모두 프로토타입 객체를 가리키지만 관점의 차이가 있다.</br>

- [[Prototype]] 프로퍼티</br>
-> 모든 객체가 가지고 있는 프로퍼티</br>
-> 객체의 입장에서 자신의 부모역할을 하는 프로토타입 객체를 가리키며 함수 객체의 경우 Function.prototype을 가리킨다.</br>

- prototype 프로퍼티</br>
-> 함수 객체만 가지고 있는 프로퍼티</br>
-> 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.</br>
-> 함수가 생성될 때 만들어지며 constructor 프로퍼티를 가지는 객체를 가리킨다.</br>
-> 함수가 생성될 때 만들어 지며 constructor 프로퍼티를 가지는 객체를 가리킨다. 이 constructor 프로퍼티는 함수 객체 자신을 가리킨다.</br> 
-> [[Prototype]] 프로퍼티는 함수 객체의 부모 객체(Function.prototype)를 가리키며 prototype 프로퍼티는 함수객체가 생성자 함수로 사용되어 객체를 생성할 때 생성된 객체의 부모 객체 역할을 하는 객체를 가리킨다. </br>

* 즉시호출함수표현식(IIFE)</br>
-> 함수의 정의와 동시에 실행되는 함수를 즉시호출함수라고한다.</br>
-> 최초 한번만 호출되며 다시 호출할 수는 없다.</br>
-> 이러한 특징을 이용, 최초 한번만 실행이 필요한 초기화 처리등에 사용가능 </br>
-> IIFE내에 처리 로직을 모아두면 혹시 있을 수도 있는 변수명 또는 함수명의 충돌을 방지가능 때문에 즉시실행함수가 사용되기도 한다.</br> 

- 내부함수 (Inner function)</br>
-> 함수 내부에 정의된 함수</br>
-> 내부함수의 자식함수는 자신을 포함하고 있는 부모함수의 변수에 접근가능, 하지만 반대로는 불가하다. </br>
-> 또한 내부함수는 부모함수의 외부에서 접근 불가</br>

- 콜백 함수</br>
-> 콜백함수는 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다.</br>
-> 자스는 일급객체이다. 따라서 자스의 함수는 흡사 변수와 같이 사용이 가능하다.</br>
-> 콜백함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정 시점에 실행된다. </br>
-> 주로 비동기식 처리 모델에 사용된다.</br>
-> 콜백함수는 콜백 큐에 들어있따 해당 이벤트가 발생하면 호출된다. </br>
-> 콜백함수는 클로저이므로 콜백큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근가능하다. </br>

===================================================================================================================================================

* 프로토타입 객체</br>
-> 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다. 따라서 자바스크립트의 동작 원리를 이해하기 위해서는 프로토타입의 개념을 잘 이해하고 있어야 한다.</br>
-> 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이도 객체를 생성가능하다.</br>
-> 자바스크립트의 모든 객체는 자신의 부모역할을 하는 Prototype객체 줄여서 Prototype에 연결되어있다. </br>
-> Prototype 객체는 생성자 함수에 의해 생성이 된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다. </br>
-> 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 갖는다. </br>
-> 객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경가능하다. </br>

* [[Prototype]]프로퍼티 vs prototype 프로퍼티</br>
-> [[Prototype]] 프로퍼티는 자신의 프로토타입 객체를 가리키는 숨겨진 프로퍼티이다. </br>
-> 함수도 객체이므로 [[Prototype]] 프로퍼티를 갖지만 일반 객체와 다르게 prototype 프로퍼티도 소유하게 된다. </br>

- [[Prototype]] 프로퍼티</br>
-> 함수를 포함한 모든 객체가 가지고 있는 프로퍼티</br>
-> 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키며 함수 객체의 경우 Function.prototype을 가리킨다. </br>
   (어떠한 방식으로 객체를 생성하여도 모든 함수 객체의 prototype 객체는 Function.prototype이다.)</br>

- prototype 프로퍼티</br>
-> 함수 객체만 가지고 있는 프로퍼티이다</br>
-> 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성될 객체의 보모 역할을 하는 프로토타입 객체를 가리킨다. </br>

* constructor 프로퍼티</br>
-> 프로토타입 객체는 constructor 프로퍼티를 갖는다. 이것은 객체의 입장에서 자신을 생성한 객체를 가리킨다. </br>
-> 예를 들어 Person() 생성자 함수에 의해 생성된 객체를 foo라고 하자. 이 foo 객체를 생성한 객체는 Person() 생성자 함수이다.</br>
   이때 foo 객체 입장에서 자신을 생성한 객체는 Person() 생성자 함수이며, foo 객체의 프로토타입 객체는 Person.prototype이다.</br>
   따라서 프로토타입 객체 Person.prototype의 constructor 프로퍼티는 Person() 생성자 함수를 가리킨다. </br>

* Prototype chain</br>
-> 자스는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]] 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것이 프로토타입 체인이다. </br>

- 객체 리터럴 방식으로 생성된 프로토타입 체인</br>
 객체 생성 방법은 3가지가 있다</br>
 -> 객체 리터럴</br>
 -> 생성자 함수</br>
 -> Object() 생성자 함수</br>

Object()는 생성자 함수이다. 그러므로 함수 객체인 Object() 생성자 함수는 prototype 프로퍼티가 있다.</br>
-> prototype 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체, 즉 프로토타입 객체를 가리킨다.</br>
-> [[Prototype]] 프로퍼티는 객체의 입장에서 자신의 부모 역할을 하는 객체, 즉 프로토타입 객체를 가리킨다. </br>

- 생성자 함수로 생성된 객체의 프로토타입 체인</br>
-> 생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다.</br>
 함수를 정의하는 방식은 3가지</br>
 -> 함수선언식</br>
 -> 함수표현식</br>
 -> Function() 생성자 함수</br>

함수표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다.

함수선언식의 경우 자스 엔진이 내부적으로 기명 함수표현식으로 변환한다. 

3가지 함수 정의 방식은 결국 Function() 생성자 함수를 통해 함수 객체를 생성한다. 따라서 어떠한 방식으로 함수 객체를 생성하여도
모든 함수 객체의 prototype 객체는 Function.prototype이다. 

foo 객체의 프로토타입 객체 Person.prototype 객체와 Person() 생성자 함수의 프로토타입 객체인 Function.prototype의 프로토타입 객체는 Object.prototype 객체이다. 이는 객체 리터럴 방식이나 생성자 함수 방식이나. 결국은 모든 객체의 부모 객체인 Object.prototype 객체에서 프로토타입 체인이 끝나기 때문이다.
이때 Object.prototype 객체를 프로토타입 체인의 종점(End of prototype chain)이라 한다.

* 프로토타입 객체의 확장</br>
-> 프로토타입 객체도 객체이므로 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다. 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다.</br>
-> 생성자 함수 Person은 프로토타입 객체 Person.prototype과 prototype 프로퍼티에 의해 바인딩 되어있다. Person.prototype 객체는 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다 따라서 생성자 함수 Person에 의해 생성된 모든 객체는 프로토타입 체인에 의해 부모객체인 Person.prototype의 메소드를 사용할 수 있게 되었다.</br>

* 기본자료형의 확장</br>
-> 자스에서 기본자료형을 제외한 모든것은 객체이다. 하지만 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다. </br>
-> 기본자료형은 객체가 아니므로 프로퍼티나 메소드를 직접 추가할 수 없다. </br>
-> 하지만 String 객체의 프로토타입 객체인 String.prototype에 메소드를 추가하면 기본자료형, 객체 모두 메소드를 사용할 수 있다.</br>

* 프로토타입 객체의 변경</br>
-> 객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는것을 의미한다. 이러한 특징을 활용, 객체의 상속을 구현가능하다. </br>

- 이때 주의할 것은 프로토타입 객체를 변경하면</br>
프로토타입 객체 변경 시점 이전에 생성된 객체</br>
-> 기존 프로토타입 객체를 [[Prototype]] 프로퍼티에 바인딩한다.</br>
프로토타입 객체 변경 시점 이후에 생성된 객체</br>
-> 변경된 프로토타입 객체를 [[Prototype]] 프로퍼티에 바인딩한다. </br>
-> 프로토티입 객체 변경 후, 생성자 함수의 Prototype 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서
   constructor 프로퍼티도 삭제되었다. 따라서 프로토타입 체인에 의해 constructor의 값은 체이닝에 의해 Object.prototype.constructor 즉 Object() 생성자 함수가 된다. </br>

* 프로토타입 체인 동작 조건</br>
-> 객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작한다. </br>
-> 객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다. </br>
