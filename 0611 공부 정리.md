1. 객체 생성 방법</br>
-> 자바스크립트는 클래스라는 개념이 없고 별도의 객체 생성 방법이 존재한다. </br>

- 객체 리터럴</br>
- 생성자 함수</br>
- object() 생성자 함수</br>

- 객체 리터럴</br>
-> 가장 일반적이고 간편한 자바스크립트의 객체 생성방식</br>
-> 중괄호{}를 사용해 객체를 생성하는데 {} 내에 아무것도 기술하지 않으면 *빈 객체가 생성된다.*</br>
-> 중괄호 내에 1개 이상의 프로퍼티 이름과 프로퍼티 값을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. </br>
-> 객체 리터럴에 의한 객체 생성 방식의 특징은 생성자 함수를 사용한 객체 생성 방식과는 달리 new 연산자를 사용할 필요없이 선언과 동시에 인스턴스가 생성된다는 것이다. </br>

- 생성자 함수</br>
-> 객체 리터럴방식과 Object() 생성자 함수 방식과는 다르게 생성자 함수를 사용하면 마치 객체를 생성하기 위한 템플릿(클래스)처럼 사용하여 구성이 동일한 객체 여러개를 간편하게 생성할 수 있다. </br>
-> 생성자 함수 이름은 일반적으로 대문자로 시작한다.</br>
-> 프로퍼티 또는 메소드명 앞에 기술한 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</br>
-> this에 바인딩 되어있는 프로퍼티와 메소드는 외부에서 참조 가능하다.</br>
-> 생성자 함수 내에서 선언된 일반 변수는 외부에서는 참조 불가. 하지만 생성자 함수 내부에서는 자유롭게 접근이 가능</br>
-> 자바스크립트의 생성자 함수는 이름 그대로 객체를 생성하는 함수, 기존 함수와 동일한 방법으로 생성자 함수를 선언하고 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. </br>
-> 이는 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것을 의미. </br>
-> new 연산자와 함께 함수를 호출하면 this 바인딩이 다르게 동작. </br>

- Object() 생성자 함수</br>
-> new 연산자와 Object() 생성자 함수를 사용하여 빈 객체를 생성할 수 있다. 빈 객체 생성 이후 프로퍼티와 메소드를 추가하여 객체를 완성하는 방법이다.</br>
-> 객체의 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 갱신된다. 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 해당 객체에 프로퍼티를 추가하고 값을 할당한다. </br>
-> 객체 리터럴 방식으로 생성된 객체는 결국 내장 함수인 object() 생성자 함수로 객체를 생성하는 것을 단순화 시킨 축약법이다. </br>


2. 함수</br>
-> 함수란 어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화 하기 위한 개념</br>
-> 스크립트의 다른 부분에서도 동일한 작업을 반복적으로 수행해야 한다면 미리 작성된 함수를 재사용할 수 있다.(코드의 재사용)</br>
-> 함수도 객체이며 호출이 가능하다.</br>
-> 함수는 일급객체이다.</br>

* 함수를 정의하는 3가지 방식</br>
- 함수선언식 (Function declaration)</br>
- 함수표현식 (Function expression)</br>
- Function() 생성자 함수</br>

- 함수선언식 (Function declaration)</br>
-> 함수선언식을 사용한 함수 정의는 function 키워드와 이하의 내용으로 구성된다.</br>
 
 - 함수명</br>
 -> 함수선언식의 경우, 함수명 생략은 불가능하다. 함수명은 함수 몸체엣 자신을 재귀적(reculsive) 호출하거나 디버거가 해당 함수를 구분할 수 있는 식별자의 역할을 한다.</br>
 - 매개변수 목록</br>
 -> 0개 이상의 목록으로 괄호로 감싸고 콤마로 분리한다. 다른 언어와의 차이점은 매개변수의 자료형을 기술하지 않는다는 것이다. 이 때문에 함수 몸체 내에서 매개변수의 자료형 체크가 필요할 수 있다.</br>
 - 함수 몸체</br>
 -> 실제 함수가 호출되었을 때 실행되는 구문들의 집합이다. 중괄호로 구문들을 감싸고 return문으로 결과값을 반환할 수 있다. 이를 반환값이라 한다.</br>

- 함수표현식 (Function expression)</br>
-> 자바스크립트의 함수는 일급 객체이다. </br>
-> 함수의 일급객체 특성을 이용하여 함수 리터럴 방식으로 함수를 정의하고 변수에 할당할 수 있는데 이런 방식을 함수표현식이라 한다.</br>

ex. var square = function(number) {</br>
  return number * number;</br>
};</br>

-> 함수표현식으로 정의한 함수는 함수명을 생략할 수 있다(anonymous function). 함수표현식에서는 함수명을 생략하는 것이 일반적이다. </br>
-> 함수는 일급객체이기 때문에 변수에 할당할 수 있는데 이 변수는 할당된 함수를 가리키는 참조값을 저장하게 된다. 함수 호출시에는 함수를 가리키는 변수명을 사용하여야 한다. </br>
-> 함수가 할당된 변수를 사용해 함수를 호출하지 않고 기명 함수의 함수명을 사용해 호출하게 되면 에러가 발생한다. 이는 함수표현식에서 사용한 함수명은 외부 코드에서 접근 불가능하기 때문이다.</br>

- Function() 생성자 함수</br>
-> 함수선언식과 함수표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function() 생성자 함수로 함수를 생성하는 것을 단순화 시킨 축약법이다. </br>
-> Function() 생성자 함수는 Function.prototype.constructor 프로퍼티로 접근할 수 있다.</br>


3. this</br>
-> 자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에 arguments 객체와 this를 암묵적으로 전달 받는다. </br>
-> 자바스크립트의 경우 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 패턴에 따라 this에 바인딩되는 객체가 달라진다. </br>

* this 공식</br>
- this는 전역객체를 가리킨다 (윈도우를 가리킨다.)</br>
- 생성자 함수 내에서의 this는 생성자 함수가 생성한 객체를 가리킨다.</br>
- 매서드 내에서 생성한 this는 매서드를 호출한 객체를 가리킨다. (메소드를 소유한 또는 호출한 객체(.앞에)를 가리킨다)</br>

* 함수호출패턴</br>
-> 전역객체는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side에서는 global 객체를 의미한다. </br>
-> 전역객체는 전역 스코프를 갖는 전역변수를 프로퍼티로 소유한다. 글로벌 영역에 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역변수의 메소드이다.</br>
-> 기본적으로 this는 전역객체에 바인딩도니다. 전역함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩된다. </br>
-> 또한 메소드의 내부함수일 경우에도 this는 전역객체에 바인딩된다.</br> 
-> 콜백함수의 경우에도 this는 전역객체에 바인딩된다. </br>
-> 재부함수의 this는 모두 전역객체에 바인딩된다. 이러한 문제를 해소하기 위해 자바스크립트는 this 바인딩을 명시적으로 할 수 있는 call,apply 메소드를 제공한다.</br>
-> 함수가 객체의 프로퍼티이면 메소드 호출 패턴으로 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체 즉 해당 메소드를 호출한 객체에 바인딩된다.</br> 
-> 프로토타입 객체도 메소드를 가질 수 있다. 프로토타입 객체 메소드 내부에서 사용된 this도 일반 베소드 방식과 마찬가지로 메소드를 호출한 객체에 바인딩된다.</br>

* 메소드 호출 패턴</br>
-> 함수가 객체의 프로퍼티이면 메소드 호출 패턴으로 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체 즉 해당 메소드를 호출한 객체에 바인딩된다. </br>
-> 프로토타입 객체도 메소드를 가질 수 있다. 프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다.</br>

* 생성자 호출 패턴</br>
-> 자바스크립트의 생성자 함수는 말 그대로 객체를 생성하는 역할을 한다.</br>
-> 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. </br>
- 생성자 함수 동작 방식</br>
-> new 연산자와 함께 생성자 함수를 호출하면 다음과 같은 수순으로 동작한다.</br>
  - 빈 객체 생성 및 this 바인딩</br>
  -> 생성자 함수의 코드가 실행되기 전 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 새로 생성하는 객체이다. 이후 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다. 그리고 생성된 빈 객체는 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. </br>
  - this를 통한 프로퍼티 생성</br>
  -> 생성된 빈 객체에 this를 사용하여 동적으로 프로퍼티나 메소드를 생성할 수 있다. this는 새로 생성된 객체를 가리키므로 this를 통해 생성한 프로퍼티와 메소드는 새로 생성된 객체에 추가된다. </br>
  - 생성된 객체 반환</br>
  -> 반환문이 없는 경우, this에 바인딩된 새로 생성한 객체가 반환된다. 명시적으로 this를 반환하여도 결과는 같다. </br>
  -> 반환문이 this가 아닌 다른 객체를 명시적으로 반환하는 경우, this가 아닌 해당 객체가 반환된다. </br>

* 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우</br>
-> 일반함수와 생성자 함수사이에 특별한 형식적 차이는 없으며 함수에 new 연산자를 붙여 호출하면 해당 함수는 생성자 함수로 동작한다.</br>
-> 객체 생성 목적으로 작성한 생성자 함수를 new 없이 호출하거나 일반함수에 new를 붙여 호출하면 오류가 발생할 수 있다. 일반함수와 생성자 함수의 호출 시 this 바인딩 방식이 다르기 때문이다.</br>
-> 일반 함수를 호출하면 this는 전역객체에 바인딩되지만 new 연산자와 함께 생성자 함수를 호출하면 this는 생성자 함수가 암묵적으로 생성한 빈 객체에 바인딩된다.</br>
-> 생성자 함수를 new 없이 호출하는 경우, 함수 Person 내부의 this는 전역객체를 가리키므로 name은 전역변수(window)에 바인딩된다. 또한 new와 함께 생성자 함수를 호출하는 경우에 암묵적으로 반환하던 this도 반환하지 않으며, 반환문이 없으므로 undefiend를 반환하게 된다. </br>
-> new 연산자와 함께 생성자 함수를 호출하는 경우, 생성자 함수 내부의 this는 생성자 함수에 의해 생성된 인스턴스를 가리킨다. </br>

* apply 호출 패턴</br>
-> this에 바인딩될 객체는 함수 호출 패턴에 의해 결정된다. 이러한 자바스크립트 엔지느이 암묵적 this 바인딩 이외에 this를 특정 객체에 명시적으로 바인징하는 방법도 제공된다, 이것을 가능하게 하는 것이 Function.prototype.apply, Function.prototype.call 메소드이다. </br>
-> 이 메소드들은 모든 함수 객체의 프로토타입 객체인 Function.prototype 객체의 메소드이다. </br>
-> apply() 메소드를 호출하는 주체는 함수이며 apply() 메소드는 this를 특정 객체에 바인딩할 뿐 본질적인 기능은 함수 호출이라는 것이다. </br>
-> apply() 메소드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메소드를 사용하는 경우이다. arguments 객체는 배열이 아니기 때문에 slice()같은 배열의 메소드를 사용할수 없으나 apply() 메소드를 이용하면 가능하다. </br>